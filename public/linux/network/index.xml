<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Réseau on wiki.ght1pc9kc.fr</title>
    <link>/linux/network.html</link>
    <description>Recent content in Réseau on wiki.ght1pc9kc.fr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    
	<atom:link href="/linux/network/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Authentification SSH par certificat</title>
      <link>/linux/network/authentification-ssh-par-certificat.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/authentification-ssh-par-certificat.html</guid>
      <description>L&amp;rsquo;objectif est de pouvoir se connecté via SSH à un serveur sans fournir de mot de passe. Cela ne sera bien-sur possible de depuis une machine ayant la clé privé d&amp;rsquo;installé !
On commence par générer la paire de clés si c&amp;rsquo;est pas déjà fait :
ssh-keygen -t rsa -C &amp;#34;your_email@example.com&amp;#34; Laisser les clés se générer dans l&amp;rsquo;emplacement par défaut et laisser la passphrase vide sinon il faudra à chaque fois renseigner la passphrase.</description>
    </item>
    
    <item>
      <title>Avoir plusieurs adresses IP sur la meme interface</title>
      <link>/linux/network/avoir-plusieurs-adresses-ip-sur-la-meme-interface.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/avoir-plusieurs-adresses-ip-sur-la-meme-interface.html</guid>
      <description>Avec Linux (je sais pas pour Windows) il est possible de configurer plusieurs adresse IP pour une même carte réseau.
Utilité A quoi ça sert ? Le cas qui m&amp;rsquo;intéressait au moment de trouver ça c&amp;rsquo;est le cas d&amp;rsquo;un serveur Apache publiant plusieurs serveurs virtuels en SSL. Dans ce cas Apache n&amp;rsquo;est pas capable pour des raisons technique de fournir cette fonctionnalité a partir d&amp;rsquo;un seul couple IP:PORT. Mais si notre serveur apache dispose de plusieurs IP il devient capable de faire ça.</description>
    </item>
    
    <item>
      <title>Configuration firewall IPTables</title>
      <link>/linux/network/configuration-firewall-iptables.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/configuration-firewall-iptables.html</guid>
      <description>Voilà une configuration valable pour un firewall IPTables qui donne sur internet à mettre dans un fichier /etc/init.d/firewall.
Pour l&amp;rsquo;installer : update-rc.d firewall defaults  Pour le désinstaller : update-rc.d -f firewall remove
#!/bin/sh ### BEGIN INIT INFO # Provides: custom firewall # Required-Start: $remote_fs $syslog $network # Required-Stop: $remote_fs $syslog $network # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: firewall initscript # Description: Custom Firewall ### END INIT INFO  # Vider les tables actuelles iptables -t filter -F # Vider les règles personnelles iptables -t filter -X # Interdire toute connexion entrante et sortante iptables -t filter -P INPUT DROP iptables -t filter -P FORWARD DROP iptables -t filter -P OUTPUT DROP # ---  # Ne pas casser les connexions etablies iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT # Autoriser loopback iptables -t filter -A INPUT -i lo -j ACCEPT iptables -t filter -A OUTPUT -o lo -j ACCEPT # ICMP (Ping) iptables -t filter -A INPUT -p icmp -j ACCEPT iptables -t filter -A OUTPUT -p icmp -j ACCEPT # ---  # SSH In iptables -t filter -A INPUT -p tcp --dport 2222 -j ACCEPT # SSH Out iptables -t filter -A OUTPUT -p tcp --dport 2222 -j ACCEPT # DNS In/Out iptables -t filter -A OUTPUT -p tcp --dport 53 -j ACCEPT iptables -t filter -A OUTPUT -p udp --dport 53 -j ACCEPT iptables -t filter -A INPUT -p tcp --dport 53 -j ACCEPT iptables -t filter -A INPUT -p udp --dport 53 -j ACCEPT # NTP Out iptables -t filter -A OUTPUT -p udp --dport 123 -j ACCEPT # WOL Out iptables -t filter -A OUTPUT -p udp --dport 9 -j ACCEPT # HTTP + HTTPS Out iptables -t filter -A OUTPUT -p tcp --dport 80 -j ACCEPT iptables -t filter -A OUTPUT -p tcp --dport 443 -j ACCEPT # HTTP + HTTPS In iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT iptables -t filter -A INPUT -p tcp --dport 443 -j ACCEPT iptables -t filter -A INPUT -p tcp --dport 8443 -j ACCEPT</description>
    </item>
    
    <item>
      <title>Configuration réseau sur VM Linux</title>
      <link>/linux/network/configuration-reseau-sur-vm-linux.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/configuration-reseau-sur-vm-linux.html</guid>
      <description>Lors de la manipulation de VM on peut avoir besoin de changer l&amp;rsquo;adresse IP ou de mettre la VM en DHCP, ce tuto explique comment faire.
Toutes les commandes se tapent connecté root :
$ sudo -i Interface réseau Les interfaces réseau se configurent dans le fichier /etc/network/interfaces, c&amp;rsquo;est là que l&amp;rsquo;on décide si le réseau est en DHCP ou en statique.
La VM par défaut est configuré en mode DHCP, on va donc voir comment la mettre en statique.</description>
    </item>
    
    <item>
      <title>DNS Securise</title>
      <link>/linux/network/dns-securise.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/dns-securise.html</guid>
      <description>L&amp;rsquo;objectif est de sécuriser les requêtes DNS en les cryptant. Sachant que Tor par défaut ne le fait pas. Il est possible de le configurer de façon a ce que les requêtes DNS passent elles aussi par Tor mais cela demande à changer le resolv.conf et a paramétrer Tor correctement. C&amp;rsquo;est pas forcément pratique même si c&amp;rsquo;est plus anonymisant que le cryptage du DNS vu que le serveur DNS ne sait pas qui lui a fait la requête.</description>
    </item>
    
    <item>
      <title>Domaines de recherche pour NetworkManager</title>
      <link>/linux/network/domaines-de-recherche-pour-networkmanager.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/domaines-de-recherche-pour-networkmanager.html</guid>
      <description>Dans les versions récentes de Gnome Shell, l&amp;rsquo;interface de NetworkManager ne donne plus la possibilité de saisir les domaines de rechercher pour les serveurs DNS. Il est possible de les mettre dans le resolv.conf mais le fichier est géré par NetworkManager et peut être écrasé n&amp;rsquo;importe quand. Un solution est donc de mettre manuellement la configuration de NetworkManager à jour dans le fichier /etc/NetworkManager/system-connections/Wired connection 1:
[connection] id=Wired connection 1 uuid=86fe8169-0452-488e-8662-0cb1dc834333 type=ethernet timestamp=1423488595 [ipv6] method=auto ip6-privacy=2 [ipv4] method=auto dns=172.</description>
    </item>
    
    <item>
      <title>Download fichier via SSH avec reprise</title>
      <link>/linux/network/download-fichier-via-ssh-avec-reprise.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/download-fichier-via-ssh-avec-reprise.html</guid>
      <description>La plus part du temps on utilise SCP mais sur des fichiers de taille conséquente, il est pratique de pouvoir reprendre le téléchargement si la connexion a été rompue ou autres. RSync permet de faire ça.
rsync --partial --progress --rsh=ssh user@1.1.1.1:/home/user/database.tar.gz database.</description>
    </item>
    
    <item>
      <title>Débloquer le wifi</title>
      <link>/linux/network/debloquer-le-wifi.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/debloquer-le-wifi.html</guid>
      <description>Après une dés-activation du wifi dans network manager de ~GnomeShell, il est impossible de le ré-activer. Pour pouvoir le ré-activer voilà la manœuvre :
$ sudo rfkill list 0: sony-wifi: Wireless LAN Soft blocked: yes Hard blocked: no 1: sony-bluetooth: Bluetooth Soft blocked: no Hard blocked: no 3: phy0: Wireless LAN Soft blocked: yes Hard blocked: yes 5: hci0: Bluetooth Soft blocked: no Hard blocked: nosudo rfkill unblock 0 Il est maintenant possible de ré-activer le wifi dans l&amp;rsquo;interface.</description>
    </item>
    
    <item>
      <title>Firefox CommandLine Options</title>
      <link>/linux/network/firefox-commandline-options.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/firefox-commandline-options.html</guid>
      <description>Voici les Paramètres concernant la gestion des profils :
 -CreateProfile nomduprofil - Vous permet de créer un nouveau profil, mais cela ne le lance pas. -CreateProfile &amp;ldquo;nomduprofil dossier&amp;rdquo; - Même chose, mais cette fois vous spécifiez l&amp;rsquo;emplacement du profil. -ProfileManager, ou -P - Lance Firefox en affichant le gestionnaire de profil. -P &amp;ldquo;nomduprofil&amp;rdquo; - Démarre Firefox directement avec le profil indiqué. -no-remote - Couplé au paramètre -P, celui-ci permet de lancer plusieurs instances du même navigateur avec des profils différents.</description>
    </item>
    
    <item>
      <title>Lancer TCPDump en non root</title>
      <link>/linux/network/lancer-tcpdump-en-non-root.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/lancer-tcpdump-en-non-root.html</guid>
      <description>groupadd tcpdump addgroup &amp;lt;username&amp;gt; tcpdump chown root.tcpdump /usr/sbin/tcpdump chmod 0750 /usr/sbin/tcpdump setcap &amp;#34;CAP_NET_RAW+eip&amp;#34; /usr/sbin/tcpdump</description>
    </item>
    
    <item>
      <title>NFS au travers de SSH</title>
      <link>/linux/network/nfs-au-travers-de-ssh.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/nfs-au-travers-de-ssh.html</guid>
      <description>Faire passer du NFS au travers du SSH n&amp;rsquo;est pas si simple que ça. Il faut :
Pré-requis Vérifier que le server SSH autorise l&amp;rsquo;IP Forwarding
Configuration du client SSH Il faut faire une redirection de port. Pour ça, soit la ligne de commande :
ssh login@server-ssh -p 2222 -L 3049:server-nfs:2049 -L 3045:server-nfs:627 -N -f Le -N permet de ne pas proposer l&amp;rsquo;invite de commande, le -f lance le process SSH en background.</description>
    </item>
    
    <item>
      <title>SSH Vérification de la clé hôte échoué</title>
      <link>/linux/network/ssh--verification-de-la-cle-host-echoue.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/ssh--verification-de-la-cle-host-echoue.html</guid>
      <description>Symptome login@debian:~$ ssh server-ssh @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that the RSA host key has just been changed. The fingerprint for the RSA key sent by the remote host is d7:16:94:8f:b9:e3:b0:16:3e:fc:e3:65:ba:d3:b4:1d. Please contact your system administrator. Add correct host key in /home/login/.</description>
    </item>
    
    <item>
      <title>SSH: Reprendre la main sur un session perdue</title>
      <link>/linux/network/ssh-reprendre-la-main-sur-un-session-perdue.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/ssh-reprendre-la-main-sur-un-session-perdue.html</guid>
      <description>Il arrive de perdre la main sur un session SSH pour différentes raisons. Dans ce cas il n&amp;rsquo;est plus possible de faire quoi que ce soir dans la console. Une manière simple de tuer la session sans tuer le terminal est de faire la suite de touche suivante :
ENTER , &#39;~&#39; , &#39;.&#39;</description>
    </item>
    
    <item>
      <title>Scanner les ports sur une IP</title>
      <link>/linux/network/scanner-les-ports-sur-une-ip.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/scanner-les-ports-sur-une-ip.html</guid>
      <description>Une commande toute conne permet de scanner les ports ouvert sur une machine et donne des tas d&amp;rsquo;information sur ce qui se trouve de l&amp;rsquo;autre coté :
nmap -sV ip-a-scanner -vvv Un truc qui peut servir pour lutter contre ça : http://portspoof.org/ ca va générer n&amp;rsquo;importe quoi sur tout les ports qu&amp;rsquo;ils soient ouvert ou fermé.</description>
    </item>
    
    <item>
      <title>WGET avec un proxy</title>
      <link>/linux/network/wget-avec-un-proxy.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/wget-avec-un-proxy.html</guid>
      <description>WGET est un programme en ligne de commande qui permet de télécharger des fichiers depuis le web. Pour une utilisation en entreprise, il se peut qu’un proxy filtre les accès au web.
## Utiliser WGET avec un proxy simple
Créer un fichier .wgetrc (n&amp;rsquo;oubliez pas le point devant le fichier) a la racine de votre répertoire personnel avec le contenu suivant :
http_proxy = http://votre_proxy:port_proxy/ use_proxy = on wait = 15  Vérifiez que ca fonctionne en rapatriant un fichier test :</description>
    </item>
    
    <item>
      <title>ssh, control de tunnel via socket</title>
      <link>/linux/network/ssh-control-de-tunnel-via-socket.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/network/ssh-control-de-tunnel-via-socket.html</guid>
      <description>Il est possible de commander une session SSH via un socket.
ssh -M -S my-ctrl-socket -fnNT -L 50000:localhost:3306 jm@sampledomain.com ssh -S my-ctrl-socket -O check jm@sampledomain.com Master running (pid=3517) ssh -S my-ctrl-socket -O exit jm@sampledomain.com Exit request sent. </description>
    </item>
    
  </channel>
</rss>
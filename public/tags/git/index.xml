<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on wiki.ght1pc9kc.fr</title>
    <link>/tags/git.html</link>
    <description>Recent content in Git on wiki.ght1pc9kc.fr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    
	<atom:link href="/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Accélérer le clonage d’un repo Git</title>
      <link>/outils/git/speedup-git-clone.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/speedup-git-clone.html</guid>
      <description>git clone --depth 1 git@gitlab.i-run.fr:irun/.git cd irun-core git fetch --depth 1 origin mabranch:mabranch git diff --name-only master.. | awk -F / &amp;#39;{print $1}&amp;#39; | uniq </description>
    </item>
    
    <item>
      <title>Changelog depuis milestone gitlab</title>
      <link>/outils/git/changelog-depuis-milestone-gitlab.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/changelog-depuis-milestone-gitlab.html</guid>
      <description>En utilisant les Milestones dans gitlab il est possible de générer des fichiers de change log pour une version donnée.
function changelog { if [ $# -lt 2 ]; then echo -e &amp;#34;USAGE: $0&amp;lt;project&amp;gt; &amp;lt;milestone&amp;gt;&amp;#34; return fi local gitlab=&amp;#34;http://framagit.org/api/v3/&amp;#34; local projectName=${1} local milestone=${2} local projectId=`curl -s -H &amp;#34;PRIVATE-TOKEN: ${GITLAB_PRIVATE_TOKEN}&amp;#34; ${gitlab}projects/search/cosmos | jq -r &amp;#39;.[0].id&amp;#39;` curl -s -H &amp;#34;PRIVATE-TOKEN: ${GITLAB_PRIVATE_TOKEN}&amp;#34; ${gitlab}projects/${projectId}/issues\?milestone\=${milestone}\&amp;amp;state\=closed\&amp;amp;order_by\=updated_at | \  jq -r &amp;#39;.[] | &amp;#34; * #\(.iid): \(.</description>
    </item>
    
    <item>
      <title>Convention de message de commit</title>
      <link>/outils/git/convention-de-message-de-commit.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/convention-de-message-de-commit.html</guid>
      <description>The contens of this page are partly based on the angular commit messages document.
 Objectif Le message de commit est ce qui décrit votre contribution. C&amp;rsquo;est pourquoi le but est de décrire ce que le commit apporte au projet;
L&amp;rsquo;entête doit être aussi explicite que possible car elle est toujours lu avec les autres message de commit.
Le corps doit fournir les informations nécessaires pour ceux qui souhaitent comprendre le commit.</description>
    </item>
    
    <item>
      <title>Git en ligne de commande</title>
      <link>/outils/git/git-en-ligne-de-commande.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/git-en-ligne-de-commande.html</guid>
      <description>Do not remove {:toc}  Voici un glossaire des lignes de commandes utile sous GIT :
Création d’un dépôt créez un nouveau dossier, ouvrez-le et exécutez la commande git init  pour créer un nouveau dépôt.
Cloner un dépôt créez une copie de votre dépôt local en exécutant la commande git clone /path/to/repository si vous utilisez un serveur distant, cette commande sera git clone username@host:/path/to/repository
Ajouter &amp;amp; valider Vous pouvez proposer un changement (l’ajouter à l’Index) en exécutant les commandes git add &amp;lt;filename&amp;gt; git add * C’est la première étape dans un workflow git basique.</description>
    </item>
    
    <item>
      <title>Git rerere</title>
      <link>/outils/git/git-rerere.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/git-rerere.html</guid>
      <description>Avec git, un des truc simpa c&amp;rsquo;est le rebase, seulement voilà, avec des rebases on se retrouve souvent avec des conflits et on en vient vite à passer plus de temps à résoudre les conflits qu&amp;rsquo;a coder.
Mais il se trouve que Git propose une commande au nom improblable pour préserver notre fragile état mental, la commande rerere.
Pour activer rerere, la seule chose à faire est de l’indiquer en configuration :</description>
    </item>
    
    <item>
      <title>Git un modèle de branches efficace</title>
      <link>/outils/git/git-un-modele-de-branches-efficace.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/git-un-modele-de-branches-efficace.html</guid>
      <description>La gestion des branches dans Subversion ou CVS n’est pas suffisamment simple et rapide pour encourager les développeurs à s’y frotter, voire les en dissuade
Partant de ce constat, tous les développeurs restent dans « le trunk », avec tous les inconvénients que cela peut avoir :
 Mr X commit en deux parties son code, rendant l’espace de quelques instants l’intégralité du projet instable Mr X commit une fonctionnalité en cours de développement, rendant le projet impossible à livrer tant qu’il n’aura pas terminé sa fonctionnalité Mr Y commit lui aussi une fonctionnalité en cours de développement, rendant le projet encore moins possible à livrer tant qu’il n’aura pas terminé sa fonctionnalité.</description>
    </item>
    
    <item>
      <title>Introduction à GIT</title>
      <link>/outils/git/introduction-a-git.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/introduction-a-git.html</guid>
      <description>Je retranscrit ici un article très intéressant trouvé sur internet à propos de GIT.
Migrer de Subversion (ou CVS) vers Git ne se suffit pas en soit pour profiter de ce qui fait de Git… Git.
Git connait un succès grandissant pour de nombreuses raisons, dont :
 La possibilité de travailler hors ligne La possibilité de définir plusieurs dépôts distants Github L’extrême facilité et rapidité avec laquelle il est possible de gérer des branches L’extrême facilité et rapidité avec laquelle il est possible de gérer des branches Les deux derniers points Surtout les trois derniers points  Après quelques rappels indispensables, nous allons nous concentrer sur le système de branches et proposer un modèle « prêt à l’emploi », largement inspiré de A successul Git branch model.</description>
    </item>
    
    <item>
      <title>Push sur plusieurs repo git</title>
      <link>/outils/git/push-sur-plusieurs-repo-git.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/push-sur-plusieurs-repo-git.html</guid>
      <description>Il est possible de pousser (push) des modifs de repo git dans plusieurs repo origin à la fois. Dans le cas où on veut un repo backup ou je sais pas quoi du genre. Pour cela il suffit d&amp;rsquo;ajouter une pushurl avec la commande suivante :
git remote set-url --add --push origin git://original/repo.git git remote set-url --add --push origin git://another/repo.git Attention, il faut vraiment ajouter les deux url de repos, celle par défaut et l&amp;rsquo;autre.</description>
    </item>
    
    <item>
      <title>Rafraichir un repo git dans Redmine</title>
      <link>/outils/refresh-redmine-repo.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/refresh-redmine-repo.html</guid>
      <description>En fait, il n&amp;rsquo;y a rien d&amp;rsquo;automatique.
Il faut commencer par cloner le repo sur le serveur remine. Ensuite on active la fonctionnalité Dépôt pour le projet et on ajoute le repo (en précisant le chemin physique). Attention c’est le chemin du répertoire .git qu’il faut renseigner, Ex /var/lib/git/longback/cosmos/.git sinon ça fonctionne pas.
Ce n’est pas fini, il car le repo ne se pull pas automatiquement. Pour cela, dans /etc/cron.d on ajoute le fichier suivant :</description>
    </item>
    
    <item>
      <title>Regrouper des repos git sans perdre l’historique</title>
      <link>/outils/git/regrouper-des-repos-git-sans-perdre-l-historique.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/regrouper-des-repos-git-sans-perdre-l-historique.html</guid>
      <description>J’ai eu le cas pour rassembler plusieurs modules dans un même projet et les mettre en tant que sous-modules :
git remote add other /path/to/XXX git fetch other git checkout -b ZZZ other/master mkdir ZZZ git mv stuff ZZZ/stuff # as necessary git commit -m &amp;#34;Moved stuff to ZZZ&amp;#34; git checkout master git merge ZZZ # should add ZZZ/ to master git commit git remote rm other git branch -d ZZZ # to get rid of the extra branch before pushing git push # if you have a remote, that is</description>
    </item>
    
    <item>
      <title>gitflow-breakdown</title>
      <link>/outils/git/gitflow-breakdown.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/gitflow-breakdown.html</guid>
      <description>Initialize    gitflow git     git flow init git init    git commit --allow-empty -m &amp;quot;Initial commit&amp;quot;    git checkout -b develop master    Connect to the remote repository    gitflow git     N/A git remote add origin git@github.com:MYACCOUNT/MYREPO    Features Create a feature branch    gitflow git     git flow feature start MYFEATURE git checkout -b feature/MYFEATURE develop    Share a feature branch    gitflow git     git flow feature publish MYFEATURE git checkout feature/MYFEATURE    git push origin feature/MYFEATURE    Get latest for a feature branch    gitflow git     git flow feature pull origin MYFEATURE git checkout feature/MYFEATURE    git pull --rebase origin feature/MYFEATURE    Finalize a feature branch    gitflow git     git flow feature finish MYFEATURE git checkout develop    git merge --no-ff feature/MYFEATURE    git branch -d feature/MYFEATURE    Push the merged feature branch    gitflow git     N/A git push origin develop    git push origin :feature/MYFEATURE (if pushed)    Releases Create a release branch    gitflow git     git flow release start 1.</description>
    </item>
    
    <item>
      <title>non fast forward updates were rejected</title>
      <link>/outils/git/non-fast-forward-updates-were-rejected.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/outils/git/non-fast-forward-updates-were-rejected.html</guid>
      <description>C’est qu’il y a un problème de synchro, s’il est réglé immédiatement c’est pas compliqué. En général c’est provoqué par le plugin EGit qui a du mal à gérer les modification de commit.
git pull origin develop git push</description>
    </item>
    
  </channel>
</rss>
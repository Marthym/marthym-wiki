<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shell on wiki.ght1pc9kc.fr</title>
    <link>/tags/shell.html</link>
    <description>Recent content in Shell on wiki.ght1pc9kc.fr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    
	<atom:link href="/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Afficher la date du jour dans le bandeau</title>
      <link>/linux/gnomeshell/afficher-la-date-du-jour-dans-le-bandeau.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/gnomeshell/afficher-la-date-du-jour-dans-le-bandeau.html</guid>
      <description>gsettings set org.gnome.shell.clock show-date true</description>
    </item>
    
    <item>
      <title>Crypter tar.gz avec mot de passe</title>
      <link>/linux/shell/crypter-tar.gz-avec-mot-de-passe.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/crypter-tar.gz-avec-mot-de-passe.html</guid>
      <description>Il est très simple de crypter un fichier tar.gz et de lui assigner un mot de passe pour par exemple l&amp;rsquo;envoyer sur un cloud public :
tar cz folder_to_encrypt | \ 	openssl enc -aes-256-cbc -e &amp;gt; out.tar.gz.enc Le mot de passe est alors demandé.
Pour decrypter/décompresser :
openssl aes-256-cbc -d -in out.tar.gz.enc | tar xz Et voilà</description>
    </item>
    
    <item>
      <title>Documents recents dans gnome-shell</title>
      <link>/linux/gnomeshell/documents-recents-dans-gnome-shell.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/gnomeshell/documents-recents-dans-gnome-shell.html</guid>
      <description>Pour les dernières versions de gnome, on peut retrouver le fichier d&amp;rsquo;historique à l&amp;rsquo;emplacement suivant: ~/.local/share/recently-used.xbel, pour les versions antérieures il se trouve à ~/.recently-used.xbel.
Effacer l&amp;rsquo;intégralité du fichier Dans un terminal, taper :
cat /dev/null &amp;gt; ~/.local/share/recently-used.xbel Puis relancer gnome-shell (Alt+F2, puis r)
Passer en mode &amp;ldquo;privé&amp;rdquo; Pour désactiver l&amp;rsquo;enregistrement des documents récents: Dans un terminal, taper :
sudo chattr +i ~/.local/share/recently-used.xbel Pour réactiver l&amp;rsquo;enregistrement des documents récents: Dans un terminal, taper :</description>
    </item>
    
    <item>
      <title>Découper et rattacher un gros fichier</title>
      <link>/linux/shell/decouper-et-rattacher-un-gros-fichier.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/decouper-et-rattacher-un-gros-fichier.html</guid>
      <description>split -b 4000m fichier.tar.gz newfichier.tar.gzcat newfichier.tar.gz.* &amp;gt; fichier.</description>
    </item>
    
    <item>
      <title>Effacer définitivement un disque dur</title>
      <link>/linux/shell/effacer-definitivement-un-disque-dur.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/effacer-definitivement-un-disque-dur.html</guid>
      <description>L&amp;rsquo;objectif est de supprimer les données d&amp;rsquo;un disque dur de façon définitive pour se protéger d&amp;rsquo;une reconstruction de la table d&amp;rsquo;index
L’utilitaire « dd » fourni avec tous les *nix et dérivés, permet de faire de nombreuses manipulations sur des fichiers ou des systèmes de fichiers comme (liste non exhaustive): Formatter une disquette à partir d’une image, découper un fichier en plusieurs morceaux, faire une image d’un DVD ou encore — et c’est ce qui nous intéresse ici — détruire les données d’un disque dur en le remplissant de zéros ou de données aléatoires.</description>
    </item>
    
    <item>
      <title>Envoyer POST avec cURL</title>
      <link>/linux/shell/envoyer-post-avec-curl.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/envoyer-post-avec-curl.html</guid>
      <description>Comment envoyer une requête POST avec le contenu d&amp;rsquo;un fichier dans le body. Le tout avec un header :
curl -H &amp;#34;Content-Type: application/json&amp;#34; \  --data &amp;#34;@salut.txt&amp;#34; http://localhost:8082/export \  | python -m json.tool Le fichier salut.txt est dans le répertoire courant &amp;hellip;
En bonus on notera la dernière ligne qui permet, si la requète retourne du JSON, de formater lisiblement le résultat.</description>
    </item>
    
    <item>
      <title>Formater simplement un XML</title>
      <link>/linux/shell/formater-simplement-un-xml.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/formater-simplement-un-xml.html</guid>
      <description>Comme Linux c&amp;rsquo;est trop bien, ya un petite commande très simple qui permet de formater proprement un XML. C&amp;rsquo;est pratique par exemple pour pouvoir l&amp;rsquo;ouvrir dans Eclipse car si le XML est formaté sur une seule ligne Eclipse pète une durite quand on veut l&amp;rsquo;ouvrir &amp;hellip;
xmllint -format -recover nonformater.xml &amp;gt; formater.</description>
    </item>
    
    <item>
      <title>Fusionner les icones d’application dans le dock</title>
      <link>/linux/gnomeshell/join-application-icon-in-dock.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/gnomeshell/join-application-icon-in-dock.html</guid>
      <description>Il y a un truc vraiment pénible avec GnomeShell et le Dock, c&amp;rsquo;est quand une application apparaît plusieurs fois. Pour une raison X ou Y, le raccourcis d&amp;rsquo;une application n&amp;rsquo;est plus regroupé avec ses instances dans le dock ce qui fait que l&amp;rsquo;on a rapidement tendance à ouvrir de nouvelle applications a chaque fois qu&amp;rsquo;on veut accédé à l&amp;rsquo;application.
C&amp;rsquo;est du à la WM_CLASS de l&amp;rsquo;application qui n&amp;rsquo;est pas configuré correctement dans le raccourcis bureau.</description>
    </item>
    
    <item>
      <title>Lecture d’arguments en bash</title>
      <link>/linux/shell/lecture-darguments-en-bash.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/lecture-darguments-en-bash.html</guid>
      <description>Pour parser les arguments d&amp;rsquo;une commande bash voici un exemple de traitement.
TEMP=`getopt -o e:m:v:r:s: --long env:,module:,version:repository:,script: \ 	-n &amp;#39;deploy.sh&amp;#39; -- &amp;#34;$@&amp;#34;` if [ $? != 0 ] ; then echo &amp;#34;Terminating...&amp;#34; &amp;gt;&amp;amp;2 ; exit 1 ; fi eval set -- &amp;#34;$TEMP&amp;#34; while true ; do case &amp;#34;$1&amp;#34; in -e|--env) ENVIRONMENT=$2 ; shift 2 ;; -m|--module) MODULE=$2 ; shift 2 ;; -v|--version) VERSION=$2 ; shift 2 ;; -r|--repository) REPOSITORY=$2 ; shift 2 ;; -s|--script) SCRIPT=$2 ; shift 2 ;; --) shift ; break ;; *) echo &amp;#34;Error with[$1:$2]&amp;#34; ; exit 1 ;; esac done if [ -z &amp;#34;$ENVIRONMENT&amp;#34; ]; then echo &amp;#34;ENVIRONMENT variable is not set&amp;#34;;fi if [ -z &amp;#34;$MODULE&amp;#34; ]; then echo &amp;#34;MODULE variable is not set&amp;#34;;fi if [ -z &amp;#34;$VERSION&amp;#34; ]; then echo &amp;#34;VERSION variable is not set&amp;#34;;fi if [ -z &amp;#34;$REPOSITORY&amp;#34; ]; then REPOSITORY=&amp;#34;releases&amp;#34;;fi if [ -z &amp;#34;$SCRIPT&amp;#34; ]; then SCRIPT=&amp;#34;deploy.</description>
    </item>
    
    <item>
      <title>Lister les fichiers d’une arborescence</title>
      <link>/linux/shell/lister-les-fichiers-d-une-arborescence.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/lister-les-fichiers-d-une-arborescence.html</guid>
      <description>Très pratique quand on fait un fix pour mettre dans la première partie
find -type f A exécuter depuis le répertoire du fix.</description>
    </item>
    
    <item>
      <title>Mettre un processus en pause</title>
      <link>/linux/shell/mettre-un-processus-en-pause.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/mettre-un-processus-en-pause.html</guid>
      <description>On est en train de compresser un film depuis 45mn et merde on a besoin de compresser un gros fichier pour l&amp;rsquo;envoyer rapidos. Pas de bol si on lance juste la compression du fichier, ça va prendre 20mn au lieu de 10s que ça prendrait normalement. On pourrait stopper la compression du film pour zipper le fichier mais on veut pas perdre les 45mn déjà effectuées &amp;hellip;
killall -STOP avidemux pour mettre le processus en pause et</description>
    </item>
    
    <item>
      <title>Modifier une fonction shell</title>
      <link>/linux/shell/modifier-une-fonction-shell.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/modifier-une-fonction-shell.html</guid>
      <description>Dans le cas d&amp;rsquo;une fonction dont on ne possède pas la paternité, on veux pouvoir profiter des mises à jour de la fonction mais sont état ne nous convient pas totalement. Par exemple la fonction suivante est pratique mais elle rejoue des tests qui, pour mon cas à moi, sont vraiment long et que je veux pouvoir skiper.
mvnwatch () { if [ &amp;#34;$#&amp;#34; -eq 0 ] then WISDOM_DEV_SERVER=/home/lo/workspace/longback/wisdom-dev-server ASSDIR=${WISDOM_DEV_SERVER}/target/wisdom/application/${PWD##*/} else local ASSDIR=$1 fi echo $ASSDIR wisdom-dev-update ${PWD##*/} ~/applications/maven/bin/mvn io.</description>
    </item>
    
    <item>
      <title>Multi-thread avec xargs</title>
      <link>/linux/shell/multi-thread-avec-xargs.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/multi-thread-avec-xargs.html</guid>
      <description>Un truc que je ne savais pas c&amp;rsquo;est qu&amp;rsquo;il est possible de faire du multi-thread avec xargs. C&amp;rsquo;est plutôt simple et ça fonctionne très bien.
Par exemple dans un script qui met à jour tous les repositories git de ma machine je peux faire ça :
find -L ~ -maxdepth 5 -path &amp;#34;*.git&amp;#34; -not -path &amp;#34;*zprezto*&amp;#34; -type d 2&amp;gt; /dev/null | \  xargs --max-proc=4 -n 1 -I {} bash -c &amp;#34;update_git_repo {}&amp;#34; Et xargs me crée un pool de 4 thread pour paralléliser ma mise à jour.</description>
    </item>
    
    <item>
      <title>Raccourcis Terminal</title>
      <link>/linux/shell/raccourcis-terminal.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/raccourcis-terminal.html</guid>
      <description>Quelques commandes/raccourcis pour aller plus vite en mode terminal.
 CTRL + A: Aller au début de la ligne CTRL + E: Aller à la fin de la ligne CTRL + [left arrow]: Avancer d&amp;rsquo;un mot CTRL + [right arrow]: Reculer d&amp;rsquo;un mot CTRL + U: Supprimer toute la ligne CTRL + K; Supprimer tout ce qui est à la droite du curseur ESC + [backspace]: Supprimer le mot qui se trouve à la gauche du curseur CTRL + W: même effet que ESC + [backspace] ALT + D: Delete the word after the cursor CTRL + R: Rechercher dans l’historique des commandes utilisées CTRL + G: Sortir du mode “recherche dans l’historique” CTRL + _: Annuler la dernière commande utilisée CTRL + L: Nettoyer la console CTRL + C: Arrêter/tuer le “foreground process” courant CTRL + Z: Suspendre/arrêter le “foreground process”  </description>
    </item>
    
    <item>
      <title>Rechercher dans les fichiers</title>
      <link>/linux/shell/rechercher-dans-les-fichiers.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/rechercher-dans-les-fichiers.html</guid>
      <description>find . -iname &amp;#39;*.jsp&amp;#39; | xargs grep &amp;#39;string&amp;#39; -sl find . -iname &amp;#39;*.jsp&amp;#39; -mtime -1 | xargs grep &amp;#39;string&amp;#39; -sl La première recherche simplement dans les fichiers, la seconde recherche dans les fichiers récemment modifiés.</description>
    </item>
    
    <item>
      <title>Recuperer le chemin d’un script bash</title>
      <link>/linux/shell/recuperer-le-chemin-d-un-script-bash.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/recuperer-le-chemin-d-un-script-bash.html</guid>
      <description>getScriptPath () { echo ${0%/*}/ } currentPath=$(getScriptPath) cd $currentPath</description>
    </item>
    
    <item>
      <title>Rendre exécutable ce qui peut l’être dans une arborescence</title>
      <link>/linux/shell/rendre-executable-ce-qui-peut-l-etre-dans-une-arborescence.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/rendre-executable-ce-qui-peut-l-etre-dans-une-arborescence.html</guid>
      <description>Dans le cas où par exemple on décompresse un fichier .zip qui contient une appli (sqldevelopper, soapUI, &amp;hellip;) on se retrouve avec un répertoire en mode 700. Du coup, seul le user qui a décompressé le zip peut lancer l&amp;rsquo;appli. Il faut donc passer les répertoire et les fichiers exécutable en 644 et 744 avec chmod. Le plus rapide pour ça est la commande suivante :
chmod a+rX -R repertoire_appli Le X permet de dire que tout les répertoire passe en exécutable et que les fichiers qui sont déjà exécutable le reste les autres ne changent pas.</description>
    </item>
    
    <item>
      <title>Renommer des fichiers sous Linux</title>
      <link>/linux/shell/renommer-des-fichiers-sous-linux.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/renommer-des-fichiers-sous-linux.html</guid>
      <description>La commande est pas compliqué mais les expression régulières c&amp;rsquo;est jamais la fête.
rename s/&amp;#34;SEARCH&amp;#34;/&amp;#34;REPLACE&amp;#34;/g *</description>
    </item>
    
    <item>
      <title>Screencast avec gnome-shell</title>
      <link>/linux/gnomeshell/screencast-avec-gnome-shell.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/gnomeshell/screencast-avec-gnome-shell.html</guid>
      <description>Un truc très sympa, Gnome-Shell intégre un outils de screencast. En effet, il suffit de faire Ctrl + Shift + Alt + R pour démarrer et arréter l&amp;rsquo;enregistrement. A la fin de l&amp;rsquo;enregistrement, le fichier résultat est déposé dans le répertoire Vidéos de l&amp;rsquo;utilisateur. Le format d&amp;rsquo;enregistrement est WebM.
Par défaut, la durée maximum d&amp;rsquo;enregistrement est de 30s, au dela l&amp;rsquo;enregistrement s&amp;rsquo;arrête de lui même. Pour changer cette durée max, il est possible de mettre à jour les settings :</description>
    </item>
    
    <item>
      <title>Suppression de fichiers en masse</title>
      <link>/linux/shell/massive-file-deletion.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/massive-file-deletion.html</guid>
      <description>Supprimer des milliers de fichiers en même temps est assez compliqué. Plusieurs solutions :
 rm -rf /mon/repertoire find /mon/repertoire/* -type f -mtime +3 -delete rsync -a --delete /tmp/empty /mon/repertoire/  le plus rapide est clairement le rsync !</description>
    </item>
    
    <item>
      <title>Suppression de fichiers par Inode</title>
      <link>/linux/shell/remove-file-by-inode.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/remove-file-by-inode.html</guid>
      <description>Il m’est arrivé l’autre jour de créer par accident un fichier &amp;lsquo;-I&amp;rsquo; et là, c’est le drame !
Impossible de supprimer ce fichier par les rm conventionnel.
La solution c’est de supprimer le fichier par son inode :
ls -il find . -inum 782263 -exec rm -i {} \; Et voilà.</description>
    </item>
    
    <item>
      <title>Supprimer un type de fichier dans une arborescence</title>
      <link>/linux/shell/supprimer-un-type-de-fichier-dans-une-arborescence.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/supprimer-un-type-de-fichier-dans-une-arborescence.html</guid>
      <description>Par exemple les fichiers générés par VSS :
rm $(find . -name *.</description>
    </item>
    
    <item>
      <title>Synchronisation Rsync</title>
      <link>/linux/shell/synchronisation-rsync.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/synchronisation-rsync.html</guid>
      <description>Très pratique quand on change de PC par exemple et que l&amp;rsquo;on veux copier sa centaine de gigs du vieux PV au nouveau.
Au travers d&amp;rsquo;une connexion directe RJ45 :
rsync -az --size-only --delete /home/kevin/source/* kevin@server.example.com:/home/kevin/destination/  -a archive, conserve tout les attribut des fichiers en l&amp;rsquo;état (date, owner, &amp;hellip;) -z active la compression --size-only ne teste que la taille du fichier pour savoir s&amp;rsquo;il doit être mis à jour.</description>
    </item>
    
    <item>
      <title>Tmux cheatcheet</title>
      <link>/linux/shell/tmux-cheatcheet.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/tmux-cheatcheet.html</guid>
      <description>Do not remove {:toc}  Sessions New Session  tmux new [-s name] [cmd] (:new) - new session  Switch Session  tmux ls (:ls) - list sessions tmux switch [-t name] (:switch) - switches to an existing session tmux as [id] [-t name] (:attach) - attaches to an existing session &amp;lt;C-a&amp;gt;c (:detach) - detach the currently attached session  Session Management  &amp;lt;C-a&amp;gt;s - list sessions &amp;lt;C-a&amp;gt;$ - name session  Close Session  tmux kill-session [-t name] (:kill-session)  Windows New Window  &amp;lt;C-a&amp;gt;c (:neww [-n name] [cmd]) - new window  Cursor Movement  &amp;lt;C-a&amp;gt;[i] (:selectw -t [i]) - go to window [i] &amp;lt;C-a&amp;gt;l - go to last window &amp;lt;C-a&amp;gt;p - go to previous window &amp;lt;C-a&amp;gt;n - go to next window  Window Management  &amp;lt;C-a&amp;gt;T - rename window &amp;lt;C-a&amp;gt;, - rename window &amp;lt;C-a&amp;gt;w - list all windows &amp;lt;C-a&amp;gt;f - find window by name &amp;lt;C-a&amp;gt;.</description>
    </item>
    
    <item>
      <title>Trouver les UUID de mes partitions</title>
      <link>/linux/shell/trouver-les-uuid-de-mes-partitions.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/trouver-les-uuid-de-mes-partitions.html</guid>
      <description>ls -l /dev/disk/by-uuid total 0 lrwxrwxrwx 1 root root 10 2009-11-05 14:10 4d7f0ae6-3945-41e2-9123-76a3858bc68a -&amp;gt; ../../sda1 lrwxrwxrwx 1 root root 10 2009-11-05 14:10 d9d24356-9c59-4888-9b00-6a316deb8aba -&amp;gt; .</description>
    </item>
    
    <item>
      <title>Trouver les gros fichiers</title>
      <link>/linux/shell/trouver-les-gros-fichiers.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/trouver-les-gros-fichiers.html</guid>
      <description>Un ligne de commande bien pratique pour ça :
du -hms /* | sort -nr | head Ca ne donne que le premier niveau de hiérarchie, il faudra relancer la commande pour affiner le recherche par sous-dossier.</description>
    </item>
    
    <item>
      <title>Télécharger un répertoire entier via FTP</title>
      <link>/linux/shell/tele-charger-un-repertoire-entier-via-ftp.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/tele-charger-un-repertoire-entier-via-ftp.html</guid>
      <description>wget -r --restrict-file-names=nocontrol ftp://username:password4@www.</description>
    </item>
    
    <item>
      <title>Unifier des PDFs</title>
      <link>/linux/shell/unifier-des-pdfs.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/unifier-des-pdfs.html</guid>
      <description>pdfunite in-1.pdf in-2.pdf in-n.pdf out.</description>
    </item>
    
    <item>
      <title>Using MPC</title>
      <link>/linux/shell/using-mpc.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/using-mpc.html</guid>
      <description>Je cherchais un lecteur de zik hyper léger avec un minimum de fonctionnalités :
 Shuffle Lecture en boucle Intégré à Gnome-shell Commandable du clavier  Résultat de la recherche, Music Player Daemon. Bon ya de la config à faire pour l’afficher dans gnome et pour le clavier mais au final ça fonctionne super. Il existe un panel de logicels pour le commander mais dans un soucis de légèreté, MPC est ce qu&amp;rsquo;il se fait de mieux.</description>
    </item>
    
    <item>
      <title>Web-server en une ligne de commande</title>
      <link>/linux/shell/web-server-en-une-ligne-de-commande.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/shell/web-server-en-une-ligne-de-commande.html</guid>
      <description> Comment lancer un serveur web en une ligne de commande bash :
while true; do { echo -e &amp;#39;HTTP/1.1 200 OK\r\n&amp;#39;; cat index.html; } | nc -l 8080; done L&amp;rsquo;intéret c&amp;rsquo;est que l&amp;rsquo;on peut voir facilement ce qui est envoyé comme entête HTTP, c&amp;rsquo;est simple et rapide !
liens  https://razvantudorica.com/08/web-server-in-one-line--bash/  </description>
    </item>
    
    <item>
      <title>gnome-shell segfault at 84 ip libcogl.so.12.1.1</title>
      <link>/linux/gnomeshell/gnome-shell-segfault-at-84-ip-libcogl.so.12.1.1.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/linux/gnomeshell/gnome-shell-segfault-at-84-ip-libcogl.so.12.1.1.html</guid>
      <description> Symptome GnomeShell ne se lance pas, un message &amp;ldquo;Oh no! Something has gone wrong&amp;rdquo; à la place. Et dans les logs :
hp kernel: [34946.429046] gnome-shell[10202]: segfault at 84 ip 00007ffa2ae877b9 sp 00007fff2bc5c7d0 error 4 in libcogl.so.12.1.1[7ffa2ae3e000+97000]  Remède sudo apt-get install --reinstall libgdk-pixbuf2.0-0 libgdk-pixbuf2.0-common Liens  http://forums.debian.net/viewtopic.php?f=5&amp;amp;t=78716&amp;amp;p=523535&amp;amp;hilit=libcogl#p523535  </description>
    </item>
    
  </channel>
</rss>